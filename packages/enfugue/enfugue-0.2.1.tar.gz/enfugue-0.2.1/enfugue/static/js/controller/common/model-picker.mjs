import{Controller}from"../base.mjs";import{TableView}from"../../view/table.mjs";import{View}from"../../view/base.mjs";import{FormView}from"../../view/forms/base.mjs";import{SearchListInputView,StringInputView,SearchListInputListView,NumberInputView}from"../../view/forms/input.mjs";import{VAEInputView,CheckpointInputView,MultiLoraInputView,MultiLycorisInputView,MultiInversionInputView}from"./model-manager.mjs";import{isEmpty,waitFor,createElementsFromString}from"../../base/helpers.mjs";import{ElementBuilder}from"../../base/builder.mjs";const E=new ElementBuilder;class ModelPickerListInputView extends SearchListInputListView{static classList=SearchListInputListView.classList.concat(["model-picker-list-input-view"])}class ModelPickerStringInputView extends StringInputView{setValue(e,t){return isEmpty(e)||(e=e.startsWith("<")?createElementsFromString(e)[0].innerText:e.split("/")[1]),super.setValue(e,t)}}class ModelPickerInputView extends SearchListInputView{static placeholder="Start typing to search modelsâ€¦";static stringInputClass=ModelPickerStringInputView;static listInputClass=ModelPickerListInputView}class ModelConfigurationFormView extends FormView{static className="model-configuration-form-view";static autoSubmit=!0;static collapseFieldSets=!0;static fieldSets={"Adaptations and Modifications":{lora:{class:MultiLoraInputView,label:"LoRA",config:{tooltip:"LoRA stands for <strong>Low Rank Adapation</strong>, it is a kind of fine-tuning that can perform very specific modifications to Stable Diffusion such as training an individual's appearance, new products that are not in Stable Diffusion's training set, etc."}},lycoris:{class:MultiLycorisInputView,label:"LyCORIS",config:{tooltip:"LyCORIS stands for <strong>LoRA beYond Conventional methods, Other Rank adaptation Implementations for Stable diffusion</strong>, a novel means of performing low-rank adaptation introduced in early 2023."}},inversion:{class:MultiInversionInputView,label:"Textual Inversion",config:{tooltip:"Textual Inversion is another kind of fine-tuning that teaches novel concepts to Stable Diffusion in a small number of images, which can be used to positively or negatively affect the impact of various prompts."}}},"Additional Models":{vae:{label:"VAE",class:VAEInputView},refiner:{label:"Refining Checkpoint",class:CheckpointInputView,config:{tooltip:"Refining checkpoints were introduced with SDXL 0.9 - these are checkpoints specifically trained to improve detail, shapes, and generally improve the quality of images generated from the base model. These are optional, and do not need to be specifically-trained refinement checkpoints - you can try mixing and matching checkpoints for different styles, though you may wish to ensure the related checkpoints were trained on the same size images."}},inpainter:{label:"Inpainting Checkpoint",class:CheckpointInputView,config:{tooltip:"An inpainting checkpoint if much like a regular Stable Diffusion checkpoint, but it additionally includes the ability to input which parts of the image can be changed and which cannot. This is used when you specifically request an image be inpainted, but is also used in many other situations in Enfugue; such as when you place an image on the canvas that doesn't cover the entire space, or use an image that has transparency in it (either before or after removing it's background.) When you don't select an inpainting checkpoint and request an inpainting operation, one will be created dynamically from the main checkpoint at runtime."}}}}}class ModelTensorRTTableView extends TableView{constructor(e,t,i){super(e,t),this.buildEngine=i}static canSort=!1;static columnFormatters={Build:function(e,t){if(!0===e)return E.span().content("Ready");{let i=E.button().content("Build").on("click",(async()=>{try{i.disabled(!0).addClass("loading-bar loading"),await this.buildEngine(t),i.removeClass("loading-bar").removeClass("loading").content("Ready")}catch(e){i.removeClass("loading-bar loading").disabled(!1)}}));return"building"===e&&i.disabled(!0).addClass("loading-bar loading"),i}}}}class ModelTensorRTStatusView extends View{static tagName="enfugue-tensorrt-status-view";static supportedNetworks={unet:"UNet",controlled_unet:"Controlled UNet",inpaint_unet:"Inpainting UNet"};static tensorRTDescription=["TensorRT is a technology created by Nvidia that transforms an AI model into one that takes advantage of hardware acceleration available on Nvidia GPUs.","As there are numerous varying architectures used by Nvidia that support this technology, these engines must be compiled by an architecture compatible with your actual hardware, rather than distributed by AI model providers.","The compilation time for each model varies, but generally takes between 15 and 30 minutes each. You can expect between 50% and 100% faster inference speeds during the engine's respective step(s).","The compiled engine is only useable for a model with the same checkpoint, LoRA, LyCORIS, Textual Inversion and engine size. If you change any of those details about this model, it will require recompilation. You can safely change model prompts as desired without requiring a new engine."];static networkDescriptions={unet:"The network used when creating images with a prompt or base image.",controlled_unet:"The network used when creating images with a control image.",inpaint_unet:"The network used when inpainting or outpainting."};constructor(e,t,i){super(e),this.status=t,this.buildEngine=i}get tableData(){return Object.getOwnPropertyNames(this.constructor.supportedNetworks).map((e=>({"Network Name":this.constructor.supportedNetworks[e],Description:this.constructor.networkDescriptions[e],Build:this.status.building===e?"building":this.status[`${e}_ready`]})))}getNameFromLabel(e){for(let t in this.constructor.supportedNetworks)if(this.constructor.supportedNetworks[t]===e)return t;throw`Unknown network ${e}`}async build(){let e=await super.build(),t=new ModelTensorRTTableView(this.config,this.tableData,(e=>this.buildEngine(this.getNameFromLabel(e["Network Name"]))));for(let t of this.constructor.tensorRTDescription)e.append(E.p().class("margin").content(t));return e.append(await t.getNode())}}class ModelPickerFormView extends FormView{static className="model-picker";static autoSubmit=!0;static fieldSets={Model:{model:{class:ModelPickerInputView}}};static tensorRTLogo="/static/img/brand/tensorrt.png";setTensorRTStatus(e,t){let i=this.node.find("#tensorrt");if(e.supported){let n=ModelTensorRTStatusView.supportedNetworks,s=Object.getOwnPropertyNames(n),o=s.length,a=s.reduce(((t,i)=>(t[i]=e[`${i}_ready`],t)),{}),r=Object.values(a).filter((e=>e)).length;isEmpty(i)?(i=E.div().id("tensorrt").append(E.img().src(this.constructor.tensorRTLogo),E.span().class("fraction").content(E.span().content(`${r}`),E.span().content(`${o}`))).on("click",(()=>t())),this.node.append(i)):i.off("click").on("click",(()=>t())).find("span.fraction").content(E.span().content(`${r}`),E.span().content(`${o}`)),e.ready?i.addClass("ready").data("tooltip","TensorRT is <strong>ready</strong>"):i.removeClass("ready").data("tooltip","TensorRT is <strong>not ready</strong>")}else isEmpty(i)||this.node.remove(i)}}class ModelPickerController extends Controller{static tensorRTStatusWindowWidth=500;static tensorRTStatusWindowHeight=750;getState(){return{model:this.formView.values,modelConfig:this.modelConfigurationFormView.values}}getDefaultState(){return{model:null,modelConfig:null}}setState(e){isEmpty(e.model)||(this.formView.suppressDefaults=!0,this.formView.setValues(e.model).then((()=>this.formView.submit()))),isEmpty(e.modelConfig)||this.modelConfigurationFormView.setValues(e.modelConfig).then(setTimeout((()=>this.modelConfigurationFormView.submit()),250))}async buildEngine(e,t){await this.model.post(`/models/${e}/tensorrt/${t}`),this.notify("info","Build Started","The engine will be busy throughout this TensorRT build. You will see a notification when it is complete, and the status indicator in the top bar will show ready or idle."),await waitFor((()=>!isEmpty(this.builtEngines[e])&&-1!==this.builtEngines[e].indexOf(t)),{interval:5e3})}async showBuildTensorRT(e){let t=await e.getStatus(),i=await this.getCurrentEngineBuildProcess(),n={supported:!1};isEmpty(t.tensorrt)||(n=t.tensorrt.base,isEmpty(t.tensorrt.inpainter)||(n.inpaint_unet_ready=t.tensorrt.inpainter.unet_ready)),isEmpty(i)||i.metadata.tensorrt_build.model!==e.name||(t.building=i.metadata.tensorrt_build.network);let s=new ModelTensorRTStatusView(this.config,n,(t=>this.buildEngine(e.name,t)));return await this.spawnWindow(`${e.name} TensorRT Status`,s,this.constructor.tensorRTStatusWindowWidth,this.constructor.tensorRTStatusWindowHeight)}async getCurrentEngineBuildProcess(){let e=await this.model.get("/invocation");for(let t of e)if(void 0!==t.metadata&&void 0!==t.metadata.tensorrt_build&&-1!==["queued","processing"].indexOf(t.status))return t;return null}async initialize(){this.builtEngines={},ModelPickerInputView.defaultOptions=async()=>(await this.model.get("/model-options")).reduce(((e,t)=>{let i="checkpoint"===t.type?"Checkpoint":"Preconfigured Model";return e[`${t.type}/${t.name}`]=`<strong>${t.name}</strong><em>${i}</em>`,e}),{}),this.formView=new ModelPickerFormView(this.config),this.modelConfigurationFormView=new ModelConfigurationFormView(this.config),this.formView.onSubmit((async e=>{let t=this.formView.suppressDefaults;if(this.formView.suppressDefaults=!1,e.model){let[i,n]=e.model.split("/");if(this.engine.model=n,this.engine.modelType=i,"model"===i){this.modelConfigurationFormView.hide();try{let e=await this.model.DiffusionModel.query({name:n}),i=await e.getStatus(),s={supported:!1};e.status=i,t&&(e._relationships.config=null),this.publish("modelPickerChange",e),isEmpty(i.tensorrt)||(s=i.tensorrt.base,isEmpty(i.tensorrt.inpainter)||(s.inpaint_unet_ready=i.tensorrt.inpainter.unet_ready)),this.formView.setTensorRTStatus(s,(()=>this.showBuildTensorRT(e)))}catch(e){this.formView.setValues({model:null}),console.error(e)}}else this.modelConfigurationFormView.show(),this.formView.setTensorRTStatus({supported:!1})}else this.formView.setTensorRTStatus({supported:!1})})),this.modelConfigurationFormView.onSubmit((async e=>{this.engine.refiner=e.refiner,this.engine.inpainter=e.inpainter,this.engine.lora=e.lora,this.engine.lycoris=e.lycoris,this.engine.inversion=e.inversion,this.engine.vae=e.vae})),this.application.container.appendChild(await this.formView.render()),this.application.container.appendChild(await this.modelConfigurationFormView.render()),this.subscribe("invocationError",(e=>{if(!isEmpty(e.metadata)&&!isEmpty(e.metadata.tensorrt_build)){let t=e.metadata.tensorrt_build.network,i=ModelTensorRTStatusView.supportedNetworks[t],n=e.metadata.tensorrt_build.model;this.notify("info","TensorRT Engine Build Failed",`${n} ${i} TensorRT Engine failed to build. Please try again.`)}})),this.subscribe("invocationComplete",(e=>{if(!isEmpty(e.metadata)&&!isEmpty(e.metadata.tensorrt_build)){let t=e.metadata.tensorrt_build.network,i=ModelTensorRTStatusView.supportedNetworks[t],n=e.metadata.tensorrt_build.model;this.notify("info","TensorRT Engine Build Complete",`Successfully built ${n} ${i} TensorRT Engine.`),isEmpty(this.builtEngines[n])&&(this.builtEngines[n]=[]),this.builtEngines[n].push(t)}}))}}export{ModelPickerController};
